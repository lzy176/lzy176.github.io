
[ 
      {
            被吃的棋子：{帅}， 我Ai
            吃它的棋子：[{兵}，{兵}]， 它用户
            吃掉吃它的棋子的棋子：[{士},{士}可有可没有]      我Ai
      }
]

1、检测棋盘上Ai棋子可以被吃掉的所有棋子，返回是一个数组 【帅，士。。。。】
2、过滤这个数组，对比每一项的level，高的就是优先级高的，返回一个对象 【帅】【士】。。。
**2-1、如果吃掉这个【帅】的棋子长度是1，也就是（吃它的棋子）的数组长度是1，去获取（吃掉吃它的棋子的棋子）数组的第一项，吃掉（吃它的棋子）**
数组过滤完了，返回null，然后走翻棋子的逻辑
  情况1：有可以翻的，那就翻
  情况2：没有翻的了，再循环全部被吃的棋子的上下左右，把可以吃的棋子过滤对比出level最高的那个，吃掉
  情况3：没有翻的了，被吃的棋子上下左右也动不了，死局，直接失败
3、检测这个对象【帅】的上下左右，是否有可以吃的棋子，并且这个可以吃的棋子key上边的is通不通为true，并且吃最大的，返回一个对象 【士】
    情况1：有可以吃的棋子，进行第四步骤
    情况2：没有可以吃的棋子了，我得跑了，检测上下左右有没有空格，
          情况1：有空格，检测这个空格的上下左右有没有对象【帅】可以吃的棋子
                情况1：有可以吃的棋子，走第四步，传的level参数为【帅】的等级，移动过去也是同样的道理，检测移动过去是否被吃
                情况2：没有可以吃的棋子，就应该跑了，移动到这个空格上
          情况2：没有空格，跑也跑不跑，吃也吃不了，就放弃了，加个key代表放弃了，步骤2重新过滤
4、在吃的之前，再过滤整个棋盘，我这个对象【帅】吃了那个【士】之后，是否会被其他棋子吃掉
    情况1：吃了【士】以后，很安全，没有被吃掉，那就过去吃掉
    情况2：吃了【士】以后，会被其他棋子吃掉，这条路走不通，给【士】加个key代表走不通，步骤3就重新检测
